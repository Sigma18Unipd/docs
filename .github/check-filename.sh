#!/bin/bash
# Copyright Â© 2025 Sigma18
# ARG_OPTIONAL_BOOLEAN([quiet],[q],[suppress most output],[off])
# ARG_VERBOSE([v])
# ARG_POSITIONAL_DOUBLEDASH([])
# ARG_POSITIONAL_INF([files],[File(s) to process],[1])
# ARG_HELP([Sigma18 - Typst file version checker.])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

die() {
  local _ret="${2:-1}"
  test "${_PRINT_HELP:-no}" = yes && print_help >&2
  echo "$1" >&2
  exit "${_ret}"
}

begins_with_short_option() {
  local first_option all_short_options='qvh'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_files=('')
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_quiet="off"
_arg_verbose=0

print_help() {
  printf '%s\n' "Sigma18 - Typst file version checker."
  printf 'Usage: %s [-q|--(no-)quiet] [-v|--verbose] [-h|--help] [--] <files-1> [<files-2>] ... [<files-n>] ...\n' "$0"
  printf '\t%s\n' "<files>: File(s) to process"
  printf '\t%s\n' "-q, --quiet, --no-quiet: suppress most output (off by default)"
  printf '\t%s\n' "-v, --verbose: Set verbose output (can be specified multiple times to increase the effect)"
  printf '\t%s\n' "-h, --help: Prints help"
}

parse_commandline() {
  _positionals_count=0
  while test $# -gt 0; do
    _key="$1"
    if test "$_key" = '--'; then
      shift
      test $# -gt 0 || break
      _positionals+=("$@")
      _positionals_count=$((_positionals_count + $#))
      shift $(($# - 1))
      _last_positional="$1"
      break
    fi
    case "$_key" in
    -q | --no-quiet | --quiet)
      _arg_quiet="on"
      test "${1:0:5}" = "--no-" && _arg_quiet="off"
      ;;
    -q*)
      _arg_quiet="on"
      _next="${_key##-q}"
      if test -n "$_next" -a "$_next" != "$_key"; then
        { begins_with_short_option "$_next" && shift && set -- "-q" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
      fi
      ;;
    -v | --verbose)
      _arg_verbose=$((_arg_verbose + 1))
      ;;
    -v*)
      _arg_verbose=$((_arg_verbose + 1))
      _next="${_key##-v}"
      if test -n "$_next" -a "$_next" != "$_key"; then
        { begins_with_short_option "$_next" && shift && set -- "-v" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
      fi
      ;;
    -h | --help)
      print_help
      exit 0
      ;;
    -h*)
      print_help
      exit 0
      ;;
    *)
      _last_positional="$1"
      _positionals+=("$_last_positional")
      _positionals_count=$((_positionals_count + 1))
      ;;
    esac
    shift
  done
}

handle_passed_args_count() {
  local _required_args_string="'files'"
  test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL version_diff: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
}

assign_positional_args() {
  local _positional_name _shift_for=$1
  _positional_names="_arg_files "
  _our_args=$((${#_positionals[@]} - 1))
  for ((ii = 0; ii < _our_args; ii++)); do
    _positional_names="$_positional_names _arg_files[$((ii + 1))]"
  done

  shift "$_shift_for"
  for _positional_name in ${_positional_names}; do
    test $# -gt 0 || break
    eval "$_positional_name=\${1}" || die "version_diff during argument parsing, possibly an Argbash bug." 1
    shift
  done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash
# ] <-- needed because of Argbash

### ------------------------------------------------------------

# Comments are written following Google's style guide for bash:
# https://google.github.io/styleguide/shellguide.html#s4-comments

# ------- Utility functions: -----

# Prints according to verbosity level
# Note that the default level is err, set at the top of the script
# Arguments:
#   $1: Text to print
#   $2: Min verbosity level
# Outputs:
#   Prints to stdout
function log() {
  if [ "$2" -gt $_arg_verbose ] || [ "$_arg_quiet" = "on" ] && [ "$2" -gt 0 ]; then
    return
  fi
  local log_level_name=""
  case "$2" in
  0) log_level_name="err" ;;
  1) log_level_name="warn" ;;
  2) log_level_name="info" ;;
  3) log_level_name="debug" ;;
  esac
  printf "%s: %s\n" "${log_level_name^^}" "$1"
}

# Extracts the file version from a file name
# Can only process filenames ending with _xyz(.typ)
# Arguments:
#   $1: File name
# Returns:
#   Version number
function filename_version() {
  local filename="$1"
  filename="${filename%.*}"
  local version="${filename##*_}"
  # check if a version has been found, in the form x.y.z
  if [[ "$version" =~ ^[0-9]+(\.[0-9]+){0,2}$ ]]; then
    echo "$version"
  else
    echo "ERRNOVER"
  fi
}

# Extracts the version declared in a typst file using our custom template
# Arguments:
#   $1: File name
# Returns:
#   Version number
function contained_version() {
  local filename="$1"
  local version
  version=$(typst query "$filename" "<versione>" --root . | jq -r '.[0].value')

  echo "$version"
}

# Process a single file to check if the version in filename matches the contained version.
# Arguments:
#   $1: Path to the file to process
# Returns:
#   0: If versions match or if the file can't be processed
#   1: If there's a version mismatch between filename and content
function process_file() {
  local file="$1"
  log "Processing file $file" 3
  if [ ! -f "$file" ]; then
    log "File $file does not exist or cannot be accessed" 1
    return
  fi

  if [[ "$file" != *.typ ]]; then
    log "File $file is not a typst file, skipping" 1
    return
  fi

  local filename_version contained_version version_diff pretty_filename
  filename_version=$(filename_version "$file")
  contained_version=$(contained_version "$file")
  pretty_filename=$(basename "$file")
  version_diff=0

  if [ "$filename_version" = "ERRNOVER" ]; then
    log "Could not extract version from \"$pretty_filename\"" 1
    return
  else
    log "Queried version from file: $contained_version" 3
    log "Extracted version from filename: $filename_version" 3
    if [ "$filename_version" = "$contained_version" ]; then
      log "Version $filename_version in filename matches contained version in $file" 2
    else
      log "Version mismatch in $pretty_filename: $filename_version != $contained_version" 0
      return 1
    fi
  fi
  return 0
}

# Recursively traverses a directory structure to check for version mismatches
# in Typst files. Processes each file found using the process_file function
# and accumulates any detected version mismatches.
# Arguments:
#   $1: Path to the directory to traverse
# Returns:
#   0: If no version mismatches were found in any file
#   1: If one or more version mismatches were detected
function traverse_dir() {
  local dir="$1"
  local version_diff=0
  log "Traversing directory $dir" 3
  for obj in "$dir"/*; do
    if [ -d "$obj" ]; then
      traverse_dir "$obj"
      obj_diff=$?
      version_diff=$((version_diff + obj_diff))
    elif [ -f "$obj" ]; then
      process_file "$obj"
      obj_diff=$?
      version_diff=$((version_diff + obj_diff))
    fi
  done
  if [ "$version_diff" -gt 0 ]; then
    return 1
  else
    return 0
  fi
}

function main() {
  if [ "$_arg_verbose" -gt 3 ]; then
    set -x
  fi

  if ! command -v jq &>/dev/null; then
    die "jq is required to run this script." 1
  fi

  if ! command -v typst &>/dev/null; then
    die "typst is required to run this script." 1
  fi

  for file in "${_arg_files[@]}"; do
    if [ -d "$file" ]; then
      traverse_dir "$file"
      output=$?
      version_diff=$((version_diff + output))
    elif [ -f "$file" ]; then
      process_file "$file"
      output=$?
      version_diff=$((version_diff + output))
    else
      log "File $file does not exist or cannot be accessed" 1
    fi
  done

  # non-zero return code if any version mismatch, makes the action fail
  if [ "$version_diff" -ne 0 ]; then
    return 1
  else
    if [ "$_arg_quiet" = "off" ]; then
      echo "INFO: All files have matching versions"
    fi
    return 0
  fi
}

main "$@"
